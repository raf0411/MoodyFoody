<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="import org.gradle.kotlin.dsl.implementation&#10;import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;)&#10;    id(&quot;com.google.gms.google-services&quot;)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;    id(&quot;kotlin-kapt&quot;)&#10;}&#10;&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;android.app.moodyfoody&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;android.app.moodyfoody&quot;&#10;        minSdk = 25&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        val geminiApiKey = localProperties.getProperty(&quot;SUPABASE_ANON_KEY&quot;) ?: &quot;&quot;&#10;        val spooncularApiKey = localProperties.getProperty(&quot;SUPABASE_URL&quot;) ?: &quot;&quot;&#10;&#10;        buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;${geminiApiKey}\&quot;&quot;)&#10;        buildConfigField(&quot;String&quot;, &quot;SPOONACULAR_API_KEY&quot;, &quot;\&quot;${spooncularApiKey}\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;${project.findProperty(&quot;GEMINI_API_KEY&quot;)}\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SPOONACULAR_API_KEY&quot;, &quot;\&quot;${project.findProperty(&quot;SPOONACULAR_API_KEY&quot;)}\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    implementation(platform(libs.firebase.bom))&#10;    implementation(libs.firebase.common.ktx)&#10;    implementation(libs.google.firebase.auth.ktx)&#10;    implementation(libs.google.firebase.firestore.ktx)&#10;    implementation(libs.androidx.core.splashscreen)&#10;    implementation(libs.kotlinx.serialization.json)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="import org.gradle.kotlin.dsl.implementation&#10;import java.util.Properties&#10;&#10;plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;)&#10;    id(&quot;com.google.gms.google-services&quot;)&#10;    id(&quot;com.google.dagger.hilt.android&quot;)&#10;    id(&quot;kotlin-kapt&quot;)&#10;}&#10;&#10;val localProperties = Properties()&#10;val localPropertiesFile = rootProject.file(&quot;local.properties&quot;)&#10;if (localPropertiesFile.exists()) {&#10;    localProperties.load(localPropertiesFile.inputStream())&#10;}&#10;&#10;android {&#10;    namespace = &quot;android.app.moodyfoody&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;android.app.moodyfoody&quot;&#10;        minSdk = 25&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;&#10;        val geminiApiKey = localProperties.getProperty(&quot;SUPABASE_ANON_KEY&quot;) ?: &quot;&quot;&#10;        val spooncularApiKey = localProperties.getProperty(&quot;SUPABASE_URL&quot;) ?: &quot;&quot;&#10;&#10;        buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;${geminiApiKey}\&quot;&quot;)&#10;        buildConfigField(&quot;String&quot;, &quot;SPOONACULAR_API_KEY&quot;, &quot;\&quot;${spooncularApiKey}\&quot;&quot;)&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;${project.findProperty(&quot;GEMINI_API_KEY&quot;)}\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SPOONACULAR_API_KEY&quot;, &quot;\&quot;${project.findProperty(&quot;SPOONACULAR_API_KEY&quot;)}\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;    // Hilt dependencies&#10;    implementation(&quot;com.google.dagger:hilt-android:2.48&quot;)&#10;    kapt(&quot;com.google.dagger:hilt-compiler:2.48&quot;)&#10;    implementation(&quot;androidx.hilt:hilt-navigation-compose:1.1.0&quot;)&#10;&#10;    implementation(platform(libs.firebase.bom))&#10;    implementation(libs.firebase.common.ktx)&#10;    implementation(libs.google.firebase.auth.ktx)&#10;    implementation(libs.google.firebase.firestore.ktx)&#10;    implementation(libs.androidx.core.splashscreen)&#10;    implementation(libs.kotlinx.serialization.json)&#10;    implementation(libs.androidx.lifecycle.viewmodel.ktx)&#10;    implementation(libs.androidx.lifecycle.viewmodel.compose)&#10;    implementation(libs.androidx.navigation.compose)&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#10;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:name=&quot;.MainApplication&quot;&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.MoodyFoody.Splash&quot;&gt;&#10;        &lt;activity&#10;            android:name=&quot;.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.MoodyFoody.Splash&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&#13;&#10;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:name=&quot;.MoodyFoodyApplication&quot;&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.MoodyFoody.Splash&quot;&gt;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:theme=&quot;@style/Theme.MoodyFoody.Splash&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/MoodyFoodyApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/MoodyFoodyApplication.kt" />
              <option name="updatedContent" value="package android.app.moodyfoody&#10;&#10;import android.app.Application&#10;import dagger.hilt.android.HiltAndroidApp&#10;&#10;@HiltAndroidApp&#10;class MoodyFoodyApplication : Application()" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/AuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/AuthRepository.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.data.repository&#10;&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.auth.FirebaseUser&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class AuthRepository {&#10;    private val auth = FirebaseAuth.getInstance()&#10;&#10;    val currentUser: FirebaseUser? get() = auth.currentUser&#10;&#10;    suspend fun signUp(email: String, password: String): Result&lt;FirebaseUser&gt; {&#10;        return try {&#10;            val result = auth.createUserWithEmailAndPassword(email, password).await()&#10;            Result.success(result.user!!)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun signIn(email: String, password: String): Result&lt;FirebaseUser&gt; {&#10;        return try {&#10;            val result = auth.signInWithEmailAndPassword(email, password).await()&#10;            Result.success(result.user!!)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        auth.signOut()&#10;    }&#10;}" />
              <option name="updatedContent" value="package android.app.moodyfoody.data.repository&#13;&#10;&#13;&#10;import com.google.firebase.auth.FirebaseAuth&#13;&#10;import com.google.firebase.auth.FirebaseUser&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class AuthRepository @Inject constructor(&#13;&#10;    private val auth: FirebaseAuth&#13;&#10;) : IAuthRepository {&#13;&#10;&#13;&#10;    override val currentUser: FirebaseUser? get() = auth.currentUser&#13;&#10;&#13;&#10;    override suspend fun signUp(email: String, password: String): Result&lt;FirebaseUser&gt; {&#13;&#10;        return try {&#13;&#10;            val result = auth.createUserWithEmailAndPassword(email, password).await()&#13;&#10;            Result.success(result.user!!)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun signIn(email: String, password: String): Result&lt;FirebaseUser&gt; {&#13;&#10;        return try {&#13;&#10;            val result = auth.signInWithEmailAndPassword(email, password).await()&#13;&#10;            Result.success(result.user!!)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun signOut() {&#13;&#10;        auth.signOut()&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/FirebaseRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/FirebaseRepository.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.data.repository&#10;&#10;import android.app.moodyfoody.data.model.UserData&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import kotlinx.coroutines.tasks.await&#10;&#10;class FirestoreRepository {&#10;    private val db = FirebaseFirestore.getInstance()&#10;&#10;    suspend fun addUser(user: UserData): Result&lt;Unit&gt; {&#10;        return try {&#10;            db.collection(&quot;users&quot;)&#10;                .document(user.id)&#10;                .set(user)&#10;                .await()&#10;            Result.success(Unit)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getUser(userId: String): Result&lt;UserData?&gt; {&#10;        return try {&#10;            val document = db.collection(&quot;users&quot;)&#10;                .document(userId)&#10;                .get()&#10;                .await()&#10;&#10;            val user = document.toObject(UserData::class.java)&#10;            Result.success(user)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getAllUsers(): Result&lt;List&lt;UserData&gt;&gt; {&#10;        return try {&#10;            val snapshot = db.collection(&quot;users&quot;)&#10;                .get()&#10;                .await()&#10;&#10;            val users = snapshot.toObjects(UserData::class.java)&#10;            Result.success(users)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package android.app.moodyfoody.data.repository&#13;&#10;&#13;&#10;import android.app.moodyfoody.data.model.UserData&#13;&#10;import com.google.firebase.firestore.FirebaseFirestore&#13;&#10;import kotlinx.coroutines.tasks.await&#13;&#10;import javax.inject.Inject&#13;&#10;import javax.inject.Singleton&#13;&#10;&#13;&#10;@Singleton&#13;&#10;class FirestoreRepository @Inject constructor(&#13;&#10;    private val db: FirebaseFirestore&#13;&#10;) : IFirestoreRepository {&#13;&#10;&#13;&#10;    override suspend fun addUser(user: UserData): Result&lt;Unit&gt; {&#13;&#10;        return try {&#13;&#10;            db.collection(&quot;users&quot;)&#13;&#10;                .document(user.id)&#13;&#10;                .set(user)&#13;&#10;                .await()&#13;&#10;            Result.success(Unit)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun getUser(userId: String): Result&lt;UserData?&gt; {&#13;&#10;        return try {&#13;&#10;            val document = db.collection(&quot;users&quot;)&#13;&#10;                .document(userId)&#13;&#10;                .get()&#13;&#10;                .await()&#13;&#10;&#13;&#10;            val user = document.toObject(UserData::class.java)&#13;&#10;            Result.success(user)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    override suspend fun getAllUsers(): Result&lt;List&lt;UserData&gt;&gt; {&#13;&#10;        return try {&#13;&#10;            val snapshot = db.collection(&quot;users&quot;)&#13;&#10;                .get()&#13;&#10;                .await()&#13;&#10;&#13;&#10;            val users = snapshot.toObjects(UserData::class.java)&#13;&#10;            Result.success(users)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.failure(e)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/IAuthRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/IAuthRepository.kt" />
              <option name="updatedContent" value="package android.app.moodyfoody.data.repository&#10;&#10;import com.google.firebase.auth.FirebaseUser&#10;&#10;interface IAuthRepository {&#10;    val currentUser: FirebaseUser?&#10;    suspend fun signUp(email: String, password: String): Result&lt;FirebaseUser&gt;&#10;    suspend fun signIn(email: String, password: String): Result&lt;FirebaseUser&gt;&#10;    fun signOut()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/IFirestoreRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/data/repository/IFirestoreRepository.kt" />
              <option name="updatedContent" value="package android.app.moodyfoody.data.repository&#10;&#10;import android.app.moodyfoody.data.model.UserData&#10;&#10;interface IFirestoreRepository {&#10;    suspend fun addUser(user: UserData): Result&lt;Unit&gt;&#10;    suspend fun getUser(userId: String): Result&lt;UserData?&gt;&#10;    suspend fun getAllUsers(): Result&lt;List&lt;UserData&gt;&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/di/AppModule.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/di/AppModule.kt" />
              <option name="updatedContent" value="package android.app.moodyfoody.di&#10;&#10;import android.app.moodyfoody.data.repository.AuthRepository&#10;import android.app.moodyfoody.data.repository.FirestoreRepository&#10;import android.app.moodyfoody.data.repository.IAuthRepository&#10;import android.app.moodyfoody.data.repository.IFirestoreRepository&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import dagger.Binds&#10;import dagger.Module&#10;import dagger.Provides&#10;import dagger.hilt.InstallIn&#10;import dagger.hilt.components.SingletonComponent&#10;import javax.inject.Singleton&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;object FirebaseModule {&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideFirebaseAuth(): FirebaseAuth = FirebaseAuth.getInstance()&#10;&#10;    @Provides&#10;    @Singleton&#10;    fun provideFirebaseFirestore(): FirebaseFirestore = FirebaseFirestore.getInstance()&#10;}&#10;&#10;@Module&#10;@InstallIn(SingletonComponent::class)&#10;abstract class RepositoryModule {&#10;&#10;    @Binds&#10;    @Singleton&#10;    abstract fun bindAuthRepository(authRepository: AuthRepository): IAuthRepository&#10;&#10;    @Binds&#10;    @Singleton&#10;    abstract fun bindFirestoreRepository(firestoreRepository: FirestoreRepository): IFirestoreRepository&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/AuthViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/AuthViewModel.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.viewModel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import android.app.moodyfoody.data.repository.AuthRepository&#10;import com.google.firebase.auth.FirebaseUser&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class AuthViewModel(&#10;    private val authRepository: AuthRepository = AuthRepository()&#10;) : ViewModel() {&#10;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#10;&#10;    private val _currentUser = MutableStateFlow(authRepository.currentUser)&#10;    val currentUser: StateFlow&lt;FirebaseUser?&gt; = _currentUser.asStateFlow()&#10;&#10;    init {&#10;        _currentUser.value = authRepository.currentUser&#10;    }&#10;&#10;    fun signUp(email: String, password: String) {&#10;        if (email.isBlank() || password.isBlank()) {&#10;            _authState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            authRepository.signUp(email, password)&#10;                .onSuccess { user -&gt;&#10;                    _currentUser.value = user&#10;                    _authState.value = AuthState.Success(&quot;Account created successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _authState.value = AuthState.Error(exception.message ?: &quot;Sign up failed&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signIn(email: String, password: String) {&#10;        if (email.isBlank() || password.isBlank()) {&#10;            _authState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _authState.value = AuthState.Loading&#10;            authRepository.signIn(email, password)&#10;                .onSuccess { user -&gt;&#10;                    _currentUser.value = user&#10;                    _authState.value = AuthState.Success(&quot;Signed in successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _authState.value = AuthState.Error(exception.message ?: &quot;Sign in failed&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _currentUser.value = null&#10;        _authState.value = AuthState.Success(&quot;Signed out successfully&quot;)&#10;    }&#10;&#10;    fun clearAuthState() {&#10;        _authState.value = AuthState.Idle&#10;    }&#10;&#10;    fun isUserSignedIn(): Boolean {&#10;        return _currentUser.value != null&#10;    }&#10;}&#10;&#10;sealed class AuthState {&#10;    object Idle : AuthState()&#10;    object Loading : AuthState()&#10;    data class Success(val message: String) : AuthState()&#10;    data class Error(val message: String) : AuthState()&#10;}&#10;" />
              <option name="updatedContent" value="package android.app.moodyfoody.viewModel&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import android.app.moodyfoody.data.repository.IAuthRepository&#13;&#10;import com.google.firebase.auth.FirebaseUser&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class AuthViewModel @Inject constructor(&#13;&#10;    private val authRepository: IAuthRepository&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _authState = MutableStateFlow&lt;AuthState&gt;(AuthState.Idle)&#13;&#10;    val authState: StateFlow&lt;AuthState&gt; = _authState.asStateFlow()&#13;&#10;&#13;&#10;    private val _currentUser = MutableStateFlow(authRepository.currentUser)&#13;&#10;    val currentUser: StateFlow&lt;FirebaseUser?&gt; = _currentUser.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        _currentUser.value = authRepository.currentUser&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signUp(email: String, password: String) {&#13;&#10;        if (email.isBlank() || password.isBlank()) {&#13;&#10;            _authState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            _authState.value = AuthState.Loading&#13;&#10;            authRepository.signUp(email, password)&#13;&#10;                .onSuccess { user -&gt;&#13;&#10;                    _currentUser.value = user&#13;&#10;                    _authState.value = AuthState.Success(&quot;Account created successfully&quot;)&#13;&#10;                }&#13;&#10;                .onFailure { exception -&gt;&#13;&#10;                    _authState.value = AuthState.Error(exception.message ?: &quot;Sign up failed&quot;)&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signIn(email: String, password: String) {&#13;&#10;        if (email.isBlank() || password.isBlank()) {&#13;&#10;            _authState.value = AuthState.Error(&quot;Email and password cannot be empty&quot;)&#13;&#10;            return&#13;&#10;        }&#13;&#10;&#13;&#10;        viewModelScope.launch {&#13;&#10;            _authState.value = AuthState.Loading&#13;&#10;            authRepository.signIn(email, password)&#13;&#10;                .onSuccess { user -&gt;&#13;&#10;                    _currentUser.value = user&#13;&#10;                    _authState.value = AuthState.Success(&quot;Signed in successfully&quot;)&#13;&#10;                }&#13;&#10;                .onFailure { exception -&gt;&#13;&#10;                    _authState.value = AuthState.Error(exception.message ?: &quot;Sign in failed&quot;)&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun signOut() {&#13;&#10;        authRepository.signOut()&#13;&#10;        _currentUser.value = null&#13;&#10;        _authState.value = AuthState.Success(&quot;Signed out successfully&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearAuthState() {&#13;&#10;        _authState.value = AuthState.Idle&#13;&#10;    }&#13;&#10;&#13;&#10;    fun isUserSignedIn(): Boolean {&#13;&#10;        return _currentUser.value != null&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;sealed class AuthState {&#13;&#10;    object Idle : AuthState()&#13;&#10;    object Loading : AuthState()&#13;&#10;    data class Success(val message: String) : AuthState()&#13;&#10;    data class Error(val message: String) : AuthState()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/FirestoreViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/FirestoreViewModel.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.viewModel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import android.app.moodyfoody.data.repository.FirestoreRepository&#10;import android.app.moodyfoody.data.model.UserData&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class FirestoreViewModel(&#10;    private val firestoreRepository: FirestoreRepository = FirestoreRepository()&#10;) : ViewModel() {&#10;&#10;    private val _firestoreState = MutableStateFlow&lt;FirestoreState&gt;(FirestoreState.Idle)&#10;    val firestoreState: StateFlow&lt;FirestoreState&gt; = _firestoreState.asStateFlow()&#10;&#10;    private val _users = MutableStateFlow&lt;List&lt;UserData&gt;&gt;(emptyList())&#10;    val users: StateFlow&lt;List&lt;UserData&gt;&gt; = _users.asStateFlow()&#10;&#10;    private val _currentUserData = MutableStateFlow&lt;UserData?&gt;(null)&#10;    val currentUserData: StateFlow&lt;UserData?&gt; = _currentUserData.asStateFlow()&#10;&#10;    fun addUser(userData: UserData) {&#10;        viewModelScope.launch {&#10;            _firestoreState.value = FirestoreState.Loading&#10;            firestoreRepository.addUser(userData)&#10;                .onSuccess {&#10;                    _firestoreState.value = FirestoreState.Success(&quot;User added successfully&quot;)&#10;                    // Refresh users list after adding&#10;                    getAllUsers()&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to add user&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun getUser(userId: String) {&#10;        viewModelScope.launch {&#10;            _firestoreState.value = FirestoreState.Loading&#10;            firestoreRepository.getUser(userId)&#10;                .onSuccess { userData -&gt;&#10;                    _currentUserData.value = userData&#10;                    _firestoreState.value = if (userData != null) {&#10;                        FirestoreState.Success(&quot;User retrieved successfully&quot;)&#10;                    } else {&#10;                        FirestoreState.Success(&quot;User not found&quot;)&#10;                    }&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to get user&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun getAllUsers() {&#10;        viewModelScope.launch {&#10;            _firestoreState.value = FirestoreState.Loading&#10;            firestoreRepository.getAllUsers()&#10;                .onSuccess { usersList -&gt;&#10;                    _users.value = usersList&#10;                    _firestoreState.value = FirestoreState.Success(&quot;Users retrieved successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to get users&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun clearFirestoreState() {&#10;        _firestoreState.value = FirestoreState.Idle&#10;    }&#10;&#10;    fun clearUserData() {&#10;        _currentUserData.value = null&#10;        _users.value = emptyList()&#10;    }&#10;}&#10;&#10;sealed class FirestoreState {&#10;    object Idle : FirestoreState()&#10;    object Loading : FirestoreState()&#10;    data class Success(val message: String) : FirestoreState()&#10;    data class Error(val message: String) : FirestoreState()&#10;}&#10;" />
              <option name="updatedContent" value="package android.app.moodyfoody.viewModel&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import android.app.moodyfoody.data.repository.IFirestoreRepository&#13;&#10;import android.app.moodyfoody.data.model.UserData&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class FirestoreViewModel @Inject constructor(&#13;&#10;    private val firestoreRepository: IFirestoreRepository&#13;&#10;) : ViewModel() {&#13;&#10;&#13;&#10;    private val _firestoreState = MutableStateFlow&lt;FirestoreState&gt;(FirestoreState.Idle)&#13;&#10;    val firestoreState: StateFlow&lt;FirestoreState&gt; = _firestoreState.asStateFlow()&#13;&#10;&#13;&#10;    private val _users = MutableStateFlow&lt;List&lt;UserData&gt;&gt;(emptyList())&#13;&#10;    val users: StateFlow&lt;List&lt;UserData&gt;&gt; = _users.asStateFlow()&#13;&#10;&#13;&#10;    private val _currentUserData = MutableStateFlow&lt;UserData?&gt;(null)&#13;&#10;    val currentUserData: StateFlow&lt;UserData?&gt; = _currentUserData.asStateFlow()&#13;&#10;&#13;&#10;    fun addUser(userData: UserData) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _firestoreState.value = FirestoreState.Loading&#13;&#10;            firestoreRepository.addUser(userData)&#13;&#10;                .onSuccess {&#13;&#10;                    _firestoreState.value = FirestoreState.Success(&quot;User added successfully&quot;)&#13;&#10;                    // Refresh users list after adding&#13;&#10;                    getAllUsers()&#13;&#10;                }&#13;&#10;                .onFailure { exception -&gt;&#13;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to add user&quot;)&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getUser(userId: String) {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _firestoreState.value = FirestoreState.Loading&#13;&#10;            firestoreRepository.getUser(userId)&#13;&#10;                .onSuccess { userData -&gt;&#13;&#10;                    _currentUserData.value = userData&#13;&#10;                    _firestoreState.value = if (userData != null) {&#13;&#10;                        FirestoreState.Success(&quot;User retrieved successfully&quot;)&#13;&#10;                    } else {&#13;&#10;                        FirestoreState.Success(&quot;User not found&quot;)&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                .onFailure { exception -&gt;&#13;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to get user&quot;)&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getAllUsers() {&#13;&#10;        viewModelScope.launch {&#13;&#10;            _firestoreState.value = FirestoreState.Loading&#13;&#10;            firestoreRepository.getAllUsers()&#13;&#10;                .onSuccess { usersList -&gt;&#13;&#10;                    _users.value = usersList&#13;&#10;                    _firestoreState.value = FirestoreState.Success(&quot;Users retrieved successfully&quot;)&#13;&#10;                }&#13;&#10;                .onFailure { exception -&gt;&#13;&#10;                    _firestoreState.value = FirestoreState.Error(exception.message ?: &quot;Failed to get users&quot;)&#13;&#10;                }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearFirestoreState() {&#13;&#10;        _firestoreState.value = FirestoreState.Idle&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clearUserData() {&#13;&#10;        _currentUserData.value = null&#13;&#10;        _users.value = emptyList()&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;sealed class FirestoreState {&#13;&#10;    object Idle : FirestoreState()&#13;&#10;    object Loading : FirestoreState()&#13;&#10;    data class Success(val message: String) : FirestoreState()&#13;&#10;    data class Error(val message: String) : FirestoreState()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/SplashViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/SplashViewModel.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.viewModel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class SplashViewModel: ViewModel() {&#10;    private val mutableStateFlow = MutableStateFlow(true)&#10;    val isLoading = mutableStateFlow.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            delay(3000)&#10;            mutableStateFlow.value = false&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package android.app.moodyfoody.viewModel&#13;&#10;&#13;&#10;import androidx.lifecycle.ViewModel&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#13;&#10;import kotlinx.coroutines.delay&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import javax.inject.Inject&#13;&#10;&#13;&#10;@HiltViewModel&#13;&#10;class SplashViewModel @Inject constructor() : ViewModel() {&#13;&#10;    private val mutableStateFlow = MutableStateFlow(true)&#13;&#10;    val isLoading = mutableStateFlow.asStateFlow()&#13;&#10;&#13;&#10;    init {&#13;&#10;        viewModelScope.launch {&#13;&#10;            delay(3000)&#13;&#10;            mutableStateFlow.value = false&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/UserManagementViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/android/app/moodyfoody/viewModel/UserManagementViewModel.kt" />
              <option name="originalContent" value="package android.app.moodyfoody.viewModel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import android.app.moodyfoody.data.repository.AuthRepository&#10;import android.app.moodyfoody.data.repository.FirestoreRepository&#10;import android.app.moodyfoody.data.model.UserData&#10;import com.google.firebase.auth.FirebaseUser&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;class UserManagementViewModel(&#10;    private val authRepository: AuthRepository = AuthRepository(),&#10;    private val firestoreRepository: FirestoreRepository = FirestoreRepository()&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow&lt;UserManagementState&gt;(UserManagementState.Idle)&#10;    val uiState: StateFlow&lt;UserManagementState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _currentUser = MutableStateFlow&lt;FirebaseUser?&gt;(authRepository.currentUser)&#10;    val currentUser: StateFlow&lt;FirebaseUser?&gt; = _currentUser.asStateFlow()&#10;&#10;    private val _userData = MutableStateFlow&lt;UserData?&gt;(null)&#10;    val userData: StateFlow&lt;UserData?&gt; = _userData.asStateFlow()&#10;&#10;    init {&#10;        _currentUser.value = authRepository.currentUser&#10;        // If user is already signed in, load their data&#10;        authRepository.currentUser?.let { user -&gt;&#10;            loadUserData(user.uid)&#10;        }&#10;    }&#10;&#10;    fun signUpAndCreateProfile(email: String, password: String, name: String) {&#10;        if (email.isBlank() || password.isBlank() || name.isBlank()) {&#10;            _uiState.value = UserManagementState.Error(&quot;All fields are required&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            authRepository.signUp(email, password)&#10;                .onSuccess { firebaseUser -&gt;&#10;                    _currentUser.value = firebaseUser&#10;&#10;                    val userData = UserData(&#10;                        id = firebaseUser.uid,&#10;                        name = name,&#10;                        email = email&#10;                    )&#10;&#10;                    firestoreRepository.addUser(userData)&#10;                        .onSuccess {&#10;                            _userData.value = userData&#10;                            _uiState.value = UserManagementState.Success(&quot;Account created successfully&quot;)&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            _uiState.value = UserManagementState.Error(&quot;Failed to create profile: ${exception.message}&quot;)&#10;                        }&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Sign up failed: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signInAndLoadProfile(email: String, password: String) {&#10;        if (email.isBlank() || password.isBlank()) {&#10;            _uiState.value = UserManagementState.Error(&quot;Email and password cannot be empty&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            authRepository.signIn(email, password)&#10;                .onSuccess { firebaseUser -&gt;&#10;                    _currentUser.value = firebaseUser&#10;                    loadUserData(firebaseUser.uid)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Sign in failed: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun loadUserData(userId: String) {&#10;        viewModelScope.launch {&#10;            firestoreRepository.getUser(userId)&#10;                .onSuccess { userData -&gt;&#10;                    _userData.value = userData&#10;                    _uiState.value = UserManagementState.Success(&quot;Profile loaded successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Failed to load profile: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _currentUser.value = null&#10;        _userData.value = null&#10;        _uiState.value = UserManagementState.Success(&quot;Signed out successfully&quot;)&#10;    }&#10;&#10;    fun updateUserProfile(userData: UserData) {&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            firestoreRepository.addUser(userData) // This will update existing user&#10;                .onSuccess {&#10;                    _userData.value = userData&#10;                    _uiState.value = UserManagementState.Success(&quot;Profile updated successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Failed to update profile: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun clearState() {&#10;        _uiState.value = UserManagementState.Idle&#10;    }&#10;&#10;    fun isUserSignedIn(): Boolean = _currentUser.value != null&#10;}&#10;&#10;sealed class UserManagementState {&#10;    object Idle : UserManagementState()&#10;    object Loading : UserManagementState()&#10;    data class Success(val message: String) : UserManagementState()&#10;    data class Error(val message: String) : UserManagementState()&#10;}&#10;" />
              <option name="updatedContent" value="package android.app.moodyfoody.viewModel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import android.app.moodyfoody.data.repository.IAuthRepository&#10;import android.app.moodyfoody.data.repository.IFirestoreRepository&#10;import android.app.moodyfoody.data.model.UserData&#10;import com.google.firebase.auth.FirebaseUser&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import javax.inject.Inject&#10;&#10;@HiltViewModel&#10;class UserManagementViewModel @Inject constructor(&#10;    private val authRepository: IAuthRepository,&#10;    private val firestoreRepository: IFirestoreRepository&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow&lt;UserManagementState&gt;(UserManagementState.Idle)&#10;    val uiState: StateFlow&lt;UserManagementState&gt; = _uiState.asStateFlow()&#10;&#10;    private val _currentUser = MutableStateFlow&lt;FirebaseUser?&gt;(authRepository.currentUser)&#10;    val currentUser: StateFlow&lt;FirebaseUser?&gt; = _currentUser.asStateFlow()&#10;&#10;    private val _userData = MutableStateFlow&lt;UserData?&gt;(null)&#10;    val userData: StateFlow&lt;UserData?&gt; = _userData.asStateFlow()&#10;&#10;    init {&#10;        _currentUser.value = authRepository.currentUser&#10;        // If user is already signed in, load their data&#10;        authRepository.currentUser?.let { user -&gt;&#10;            loadUserData(user.uid)&#10;        }&#10;    }&#10;&#10;    fun signUpAndCreateProfile(email: String, password: String, name: String) {&#10;        if (email.isBlank() || password.isBlank() || name.isBlank()) {&#10;            _uiState.value = UserManagementState.Error(&quot;All fields are required&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            authRepository.signUp(email, password)&#10;                .onSuccess { firebaseUser -&gt;&#10;                    _currentUser.value = firebaseUser&#10;&#10;                    val userData = UserData(&#10;                        id = firebaseUser.uid,&#10;                        name = name,&#10;                        email = email&#10;                    )&#10;&#10;                    firestoreRepository.addUser(userData)&#10;                        .onSuccess {&#10;                            _userData.value = userData&#10;                            _uiState.value = UserManagementState.Success(&quot;Account created successfully&quot;)&#10;                        }&#10;                        .onFailure { exception -&gt;&#10;                            _uiState.value = UserManagementState.Error(&quot;Failed to create profile: ${exception.message}&quot;)&#10;                        }&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Sign up failed: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signInAndLoadProfile(email: String, password: String) {&#10;        if (email.isBlank() || password.isBlank()) {&#10;            _uiState.value = UserManagementState.Error(&quot;Email and password cannot be empty&quot;)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            authRepository.signIn(email, password)&#10;                .onSuccess { firebaseUser -&gt;&#10;                    _currentUser.value = firebaseUser&#10;                    loadUserData(firebaseUser.uid)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Sign in failed: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    private fun loadUserData(userId: String) {&#10;        viewModelScope.launch {&#10;            firestoreRepository.getUser(userId)&#10;                .onSuccess { userData -&gt;&#10;                    _userData.value = userData&#10;                    _uiState.value = UserManagementState.Success(&quot;Profile loaded successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Failed to load profile: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun signOut() {&#10;        authRepository.signOut()&#10;        _currentUser.value = null&#10;        _userData.value = null&#10;        _uiState.value = UserManagementState.Success(&quot;Signed out successfully&quot;)&#10;    }&#10;&#10;    fun updateUserProfile(userData: UserData) {&#10;        viewModelScope.launch {&#10;            _uiState.value = UserManagementState.Loading&#10;&#10;            firestoreRepository.addUser(userData) // This will update existing user&#10;                .onSuccess {&#10;                    _userData.value = userData&#10;                    _uiState.value = UserManagementState.Success(&quot;Profile updated successfully&quot;)&#10;                }&#10;                .onFailure { exception -&gt;&#10;                    _uiState.value = UserManagementState.Error(&quot;Failed to update profile: ${exception.message}&quot;)&#10;                }&#10;        }&#10;    }&#10;&#10;    fun clearState() {&#10;        _uiState.value = UserManagementState.Idle&#10;    }&#10;&#10;    fun isUserSignedIn(): Boolean = _currentUser.value != null&#10;}&#10;&#10;sealed class UserManagementState {&#10;    object Idle : UserManagementState()&#10;    object Loading : UserManagementState()&#10;    data class Success(val message: String) : UserManagementState()&#10;    data class Error(val message: String) : UserManagementState()&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;2.2.0&quot; apply false&#10;    id(&quot;com.google.gms.google-services&quot;) version &quot;4.4.3&quot; apply false&#10;}&#10;&#10;buildscript {&#10;    dependencies {&#10;        classpath(libs.google.services)&#10;    }&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;    id(&quot;org.jetbrains.kotlin.plugin.serialization&quot;) version &quot;2.2.0&quot; apply false&#10;    id(&quot;com.google.gms.google-services&quot;) version &quot;4.4.3&quot; apply false&#10;    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.48&quot; apply false&#10;}&#10;&#10;buildscript {&#10;    dependencies {&#10;        classpath(libs.google.services)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>